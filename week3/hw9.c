/*
009. 數位電路模擬II

模擬一個數位IC，內有回饋電路與紀錄器電路。
輸入N 是二進位 10 位元，輸出是二進位 14 位元。
輸入範圍從 0000000000到 1111111111 (十進位 0~1023)

數位IC內有一個回饋電路，回饋方式：
C(N) = N 當 N(十進位) 為 0 或 N為 1 時
C(N) = C(N/2) 當 N(十進位) 為偶數
C(N) = C((N+1)/2) 當 N(十進位) 為奇數

數位IC內有一個紀錄器 R，會記錄回饋電路的回饋次數。
R(N) = [C(N) 的回饋次數]。例如 N=00001010 (十進位 10)，
即 C(10)= C(5)=C(3)=C(2)=C(1)=1，則 R(10) = 4，共回饋 4 次。

此電路另有一個紀錄器 T，會加總所跑過的0~N次電路回饋次數，
即 T(N) = R(0) + R(1) +...+ R(N)。
以二進位制輸出所有回饋次數加總後的結果。
例如 T(10) = R(0)+R(1)+R(2)+R(3)+R(4)+...+R(10) = 00000000011001(十進位為 25)。

當輸入 -1時，結束執行。

【輸入說明】
第1行輸入第1個測試案例資料（二進位 10 bit）
第2行輸入0分隔資料
第2行輸入第2個測試案例資料（二進位 10 bit）
....
直到輸入-1 結束

範例輸入說明：
0000000011（十進位3）
0(中間0分隔)
0000001001(十進位9)
-1(-1結束輸入)

【輸出說明】
每一行輸出一個測試案例資料的結果（二進位 14 bit）。

範例輸出說明：
00000000000011 （T(3) = R(0) + R(1) + R(2) + R(3) = 0 + 0 + 1 + 2 = 3）
00000000010101 ( T(9) = R(0) + R(1) + R(2) + R(3) + R(4) + R(5) + R(6) + R(7) +
R(8) + R(9) = 0 + 0 + 1 +2 + 2 + 3 + 3 + 3 + 3 + 4 = 21)


【測試資料一】
輸入：
0000000000
0
1111111111
0
1000000001
-1

輸出：
00000000000000
10001111110111
01000000001011

【測試資料二】
輸入：
1111001111
0
1001001001
0
0010010010
0
1000001000
-1

輸出：
10001000010111
01001011011011
00001110010001
01000001010001

【測試資料三】
輸入：
1110101111
0
0000010011
0
1111010110
0
1010111011
0
1110110101
-1

輸出：
10000011010111
00000001000000
10001001011101
01011101001111
10000100010011
*/

#include <math.h>
#include <stdio.h>
#include <string.h>

int C(int N, int *count);
int T(int N);
int R(int N);

int main() {
  char input[11] = {0};
  while (1) {
    scanf("%s", input);
    if (input[0] == '-' && input[1] == '1') {
      break;
    }
    if (input[0] == '0' && strlen(input) == 1) {
      continue;
    }
    int N = 0;
    for (int i = 0; i < 10; i++) {
      N += ((int)input[i] - 48) * pow(2, 9 - i);
    }

    int result = T(N);
    // printf("%014d\n", result);
    for (int i = 13; i >= 0; i--) {
      // 右移運算符(>>)：將整數向右移動i位，然後與1進行位元與(&)運算，以檢查該位元是否為1
      int bit = (result >> i) & 1;
      printf("%d", bit);
    }
    printf("\n");
  }
  return 0;
}

int C(int N, int *count) {
  if (N == 0 || N == 1) {
    return *count;
  } else if (N % 2 == 0) {
    (*count)++;
    return C(N / 2, count);
  } else {
    (*count)++;
    return C((N + 1) / 2, count);
  }
}

int R(int N) {
  int count = 0;

  C(N, &count);

  return count;
}

/*int T(int N) {
  int sum = 0;
  while (N >= 0) {
    sum += R(N);
    N--;
  }
  printf("sum= %d\n", sum);
  return sum;
}*/

int T(int N) {
  int sum = 0;
  for (int i = 0; i <= N; i++) {
    sum += R(i);
  }
  return sum;
}
